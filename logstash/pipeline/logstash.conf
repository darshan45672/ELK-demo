input {
  file {
    path => "/logs/app.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "plain"
  }
}

filter {
  # Parse the log line using grok
  grok {
    match => { 
      "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{WORD:service} %{GREEDYDATA:kv_data}"
    }
  }

  # Extract key-value pairs
  kv {
    source => "kv_data"
    field_split => " "
    value_split => "="
    target => "fields"
  }

  # Convert string fields to appropriate types
  mutate {
    convert => {
      "[fields][latencyMs]" => "integer"
      "[fields][orderId]" => "integer"
      "[fields][userId]" => "integer"
    }
    rename => {
      "[fields][orderId]" => "orderId"
      "[fields][userId]" => "userId"
      "[fields][latencyMs]" => "latencyMs"
      "[fields][errorCode]" => "errorCode"
    }
    remove_field => ["kv_data", "fields", "message"]
  }

  # Parse timestamp
  date {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
    timezone => "UTC"
  }

  # Add custom fields
  mutate {
    add_field => {
      "environment" => "production"
      "application" => "checkout-service"
    }
  }

  # Categorize errors
  if [errorCode] {
    mutate {
      add_field => { "has_error" => "true" }
    }
    if [errorCode] == "PAYMENT_FAILED" {
      mutate {
        add_field => { "error_category" => "payment" }
      }
    } else if [errorCode] == "TIMEOUT" {
      mutate {
        add_field => { "error_category" => "performance" }
      }
    } else if [errorCode] == "INVALID_CART" {
      mutate {
        add_field => { "error_category" => "validation" }
      }
    } else {
      mutate {
        add_field => { "error_category" => "unknown" }
      }
    }
  } else {
    mutate {
      add_field => { "has_error" => "false" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["${ELASTICSEARCH_HOSTS}"]
    index => "checkout-logs-%{+YYYY.MM.dd}"
  }

  # Useful for debugging
  stdout {
    codec => rubydebug
  }
}
